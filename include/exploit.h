#pragma once
#include <string>
#include <optional>
#include <unordered_map>
#include <iostream>

class BaseExploit {
public:
	BaseExploit(std::string name) {
		this->m_name = name;
		std::cout << "Initializing exploit " << name << std::endl;
	}

	virtual ~BaseExploit() {} // Déclare le destructeur virtuel pour la polymorphie
	virtual void tick() = 0; // Méthode virtuelle pure pour être redéfinie dans les classes dérivées
	virtual bool* get_enabled_ptr() = 0;
	virtual void reset_original_data(void* object) = 0;
	virtual void* get_object_ptr() = 0;

	std::string get_name() { return this->m_name; }

	bool is_enabled() {
		return (*get_enabled_ptr()) == true;
	}

protected:
	std::string m_name;
};

//a static exploit is a exploit that does not have a use case for original_data
template <typename Wrapper, typename T>
class StaticExploit : public BaseExploit {
public:
	StaticExploit(std::string name) : BaseExploit(name) {};

protected:
	virtual T get_static_data() = 0;
	virtual void write(Wrapper object, T data) = 0;

	void reset_original_data(void* object) override { };

	virtual void enable() {
		write((Wrapper)get_object_ptr(), get_static_data());
		*get_enabled_ptr() = true;
	};
public:
	void tick() override {
		if (!is_enabled()) {
			return;
		}

		enable();
	}
};

template <typename Wrapper, typename T> //where T is a struct to original data
class Exploit : public BaseExploit {
public:
	Exploit(std::string name) : BaseExploit(name) {};
protected:
	virtual void read_data(T* buffer) = 0;
	virtual T get_write_data() = 0;
	virtual void write(Wrapper object, T data) = 0;

	virtual void enable() {
		write((Wrapper)get_object_ptr(), get_write_data());
		*get_enabled_ptr() = true;
	};

	void reset_original_data(void* object = nullptr) override {
		
		Wrapper wrapper = (Wrapper)(object ? object : get_object_ptr());

		std::optional<T> original_data = get_original_data(wrapper);
		if (original_data) {
			write(wrapper, *original_data);
			this->original_data.erase(wrapper);
		}
	}

	virtual void disable() {
		reset_original_data(get_object_ptr());
		*get_enabled_ptr() = false;
	};

	std::optional<T> get_original_data(Wrapper object) {
		if (!this->original_data.contains(object)) {
			return std::nullopt;
		}

		return this->original_data[object];
	}
public:
	void tick() override {
		Wrapper object = (Wrapper)get_object_ptr();
		if (!is_enabled()) {
			if (original_data.contains(object))
				disable();
			return;
		}

		if (!original_data.contains(object)) {
			T buffer;
			read_data(&buffer);
			original_data[object] = buffer;
		}

		enable();
	}

private:
	std::unordered_map<Wrapper, T> original_data;
};