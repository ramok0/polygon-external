#include <ue4.hpp>
#include <cache.hpp>


//inline std::unordered_map<void*, float> original_time_between_shots;
//inline std::unordered_map<void*, float> original_mobility;
//inline std::unordered_map<void*, std::unordered_map<uint64_t, void*>> original_reload_animations;
//inline std::unordered_map<void*, float> original_AimDownTimeMultiplier;
void exploits::infinite_stamina(void)
{
	if (!config::config->data()->infinite_stamina) return;

	ONCE_GET_OFFSET("/Script/POLYGON.HealthStatsComponent", "Stamina", StaminaOffset);

	if (!StaminaOffset) return;
	if (!cache::LocalHealthStatsComponent) return;

	driver::write<float>((uintptr_t)cache::LocalHealthStatsComponent + StaminaOffset, 100.f);
}

void exploits::rapid_fire()
{
	ONCE_GET_OFFSET("/Script/POLYGON.Item_Gun_General", "TimeBetweenShots", TimeBetweenShotsOffset);
	if (!TimeBetweenShotsOffset) return;
	if (!cache::LocalCurrentWeapon) return;

	if (!config::config->data()->rapid_fire) {
		if (original_weapon_data.contains(cache::LocalCurrentWeapon) && original_weapon_data[cache::LocalCurrentWeapon].cached_firerate)
		{
			driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + TimeBetweenShotsOffset, original_weapon_data[cache::LocalCurrentWeapon].TimeBetweenShots);
			//printf("resetting TimeBetweenShots back to %f\n", original_weapon_data[cache::LocalCurrentWeapon].TimeBetweenShots);
			original_weapon_data[cache::LocalCurrentWeapon].cached_firerate = false;
		}
		return;
	}

	if (!original_weapon_data.contains(cache::LocalCurrentWeapon))
	{
		weapon_t data = { 0 };

		original_weapon_data[cache::LocalCurrentWeapon] = data;
		original_weapon_data[cache::LocalCurrentWeapon].TimeBetweenShots = cache::LocalCurrentWeapon->get_time_between_shots();
	//	printf("TimeBetweenShots is now %f\n", original_weapon_data[cache::LocalCurrentWeapon].TimeBetweenShots);
		original_weapon_data[cache::LocalCurrentWeapon].cached_firerate = true;
	}
	else if (original_weapon_data.contains(cache::LocalCurrentWeapon) && !original_weapon_data[cache::LocalCurrentWeapon].cached_firerate)
	{
		original_weapon_data[cache::LocalCurrentWeapon].TimeBetweenShots = cache::LocalCurrentWeapon->get_time_between_shots();
	//	printf("TimeBetweenShots is now %f\n", original_weapon_data[cache::LocalCurrentWeapon].TimeBetweenShots);
		original_weapon_data[cache::LocalCurrentWeapon].cached_firerate = true;
	}

	driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + TimeBetweenShotsOffset, config::config->data()->time_between_shots);
}

void exploits::no_spread(void)
{
	ONCE_GET_OFFSET("/Script/POLYGON.Item_Gun_General", "CurrentSpread", CurrentSpreadOffset);
	ONCE_GET_OFFSET("/Script/POLYGON.Item_Gun_General", "SpreadShot", SpreadShotOffset);
	if (!SpreadShotOffset || !CurrentSpreadOffset || !cache::LocalCurrentWeapon) return;

	if (!config::config->data()->no_spread) {
		if (original_weapon_data.contains(cache::LocalCurrentWeapon) && original_weapon_data[cache::LocalCurrentWeapon].cached_spread)
		{
			driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + CurrentSpreadOffset, original_weapon_data[cache::LocalCurrentWeapon].CurrentSpread);
			driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + SpreadShotOffset, original_weapon_data[cache::LocalCurrentWeapon].SpreadShot);
			original_weapon_data[cache::LocalCurrentWeapon].cached_spread = false;
		}
		return;
	}

	if (!original_weapon_data.contains(cache::LocalCurrentWeapon))
	{
		weapon_t data = { 0 };
		original_weapon_data[cache::LocalCurrentWeapon] = data;
		original_weapon_data[cache::LocalCurrentWeapon].CurrentSpread = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + CurrentSpreadOffset);
		original_weapon_data[cache::LocalCurrentWeapon].SpreadShot = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + SpreadShotOffset);
		original_weapon_data[cache::LocalCurrentWeapon].cached_spread = true;

	}
	else if (original_weapon_data.contains(cache::LocalCurrentWeapon) && !original_weapon_data[cache::LocalCurrentWeapon].cached_spread)
	{
		original_weapon_data[cache::LocalCurrentWeapon].CurrentSpread = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + CurrentSpreadOffset);
		original_weapon_data[cache::LocalCurrentWeapon].SpreadShot = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + SpreadShotOffset);
		original_weapon_data[cache::LocalCurrentWeapon].cached_spread = true;
	}

	driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + CurrentSpreadOffset, 0.f);
	driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + SpreadShotOffset, 0.f);
}

void exploits::no_recoil(void)
{
	ONCE_GET_OFFSET("/Script/POLYGON.Item_Gun_General", "GunUpRecoil", GunUpRecoilOffset);
	ONCE_GET_OFFSET("/Script/POLYGON.Item_Gun_General", "GunBackwardRecoil", GunBackwardRecoilOffset);
	ONCE_GET_OFFSET("/Script/POLYGON.Item_Gun_General", "GunRecoilAlphaPerShot", GunRecoilAlphaPerShotOffset);
	ONCE_GET_OFFSET("/Script/POLYGON.Item_Gun_General", "GunRecoilLift", GunRecoilLiftOffset);

	if (!GunUpRecoilOffset || !GunBackwardRecoilOffset || !GunRecoilAlphaPerShotOffset || !GunRecoilLiftOffset || !cache::LocalCurrentWeapon) return;

	if (!config::config->data()->no_recoil) {
		if (original_weapon_data.contains(cache::LocalCurrentWeapon) && original_weapon_data[cache::LocalCurrentWeapon].cached_recoil)
		{
			driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + GunUpRecoilOffset, original_weapon_data[cache::LocalCurrentWeapon].GunUpRecoil);
			driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + GunBackwardRecoilOffset, original_weapon_data[cache::LocalCurrentWeapon].GunBackwardRecoil);
			driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + GunRecoilAlphaPerShotOffset, original_weapon_data[cache::LocalCurrentWeapon].GunRecoilAlphaPerShot);
			driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + GunRecoilLiftOffset, original_weapon_data[cache::LocalCurrentWeapon].GunRecoilLift);
			original_weapon_data[cache::LocalCurrentWeapon].cached_recoil = false;
		}
		return;
	}

	if (!original_weapon_data.contains(cache::LocalCurrentWeapon))
	{
		weapon_t data = { 0 };
		original_weapon_data[cache::LocalCurrentWeapon] = data;
		original_weapon_data[cache::LocalCurrentWeapon].GunUpRecoil = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + GunUpRecoilOffset);
		original_weapon_data[cache::LocalCurrentWeapon].GunBackwardRecoil = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + GunBackwardRecoilOffset);
		original_weapon_data[cache::LocalCurrentWeapon].GunRecoilAlphaPerShot = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + GunRecoilAlphaPerShotOffset);
		original_weapon_data[cache::LocalCurrentWeapon].GunRecoilLift = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + GunRecoilLiftOffset);
		original_weapon_data[cache::LocalCurrentWeapon].cached_recoil = true;
		
	}
	else if (original_weapon_data.contains(cache::LocalCurrentWeapon) && !original_weapon_data[cache::LocalCurrentWeapon].cached_recoil)
	{
		original_weapon_data[cache::LocalCurrentWeapon].GunUpRecoil = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + GunUpRecoilOffset);
		original_weapon_data[cache::LocalCurrentWeapon].GunBackwardRecoil = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + GunBackwardRecoilOffset);
		original_weapon_data[cache::LocalCurrentWeapon].GunRecoilAlphaPerShot = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + GunRecoilAlphaPerShotOffset);
		original_weapon_data[cache::LocalCurrentWeapon].GunRecoilLift = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + GunRecoilLiftOffset);
		original_weapon_data[cache::LocalCurrentWeapon].cached_recoil = true;
	}

	driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + GunUpRecoilOffset, 0.f);
	driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + GunBackwardRecoilOffset, 0.f);
	driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + GunRecoilAlphaPerShotOffset, 0.f);
	driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + GunRecoilLiftOffset, 0.f);
}

void exploits::instantaim()
{
	ONCE_GET_OFFSET("/Script/POLYGON.Item_Gun_General", "AimDownTimeMultiplier", AimDownTimeMultiplierOffset);
	if (!AimDownTimeMultiplierOffset) return;
	if (!cache::LocalCurrentWeapon) return;

	if (!config::config->data()->instant_aim) {
		if (original_weapon_data.contains(cache::LocalCurrentWeapon) && original_weapon_data[cache::LocalCurrentWeapon].cached_aim_down_time_multiplier)
		{
			driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + AimDownTimeMultiplierOffset, original_weapon_data[cache::LocalCurrentWeapon].AimDownTimeMultiplier);
			original_weapon_data[cache::LocalCurrentWeapon].cached_aim_down_time_multiplier = false;
		}
		return;
	}

	if (!original_weapon_data.contains(cache::LocalCurrentWeapon))
	{
		weapon_t data = { 0 };
		original_weapon_data[cache::LocalCurrentWeapon] = data;
		original_weapon_data[cache::LocalCurrentWeapon].AimDownTimeMultiplier = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + AimDownTimeMultiplierOffset);
		original_weapon_data[cache::LocalCurrentWeapon].cached_aim_down_time_multiplier = true;
	}
	else if (original_weapon_data.contains(cache::LocalCurrentWeapon) && !original_weapon_data[cache::LocalCurrentWeapon].cached_aim_down_time_multiplier)
	{
		original_weapon_data[cache::LocalCurrentWeapon].AimDownTimeMultiplier = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + AimDownTimeMultiplierOffset);
		original_weapon_data[cache::LocalCurrentWeapon].cached_aim_down_time_multiplier = true;
	}

	driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + AimDownTimeMultiplierOffset, 1000.f);
}

void exploits::fast_move()
{
	ONCE_GET_OFFSET("/Script/POLYGON.Item_Gun_General", "Mobility", MobilityOffset);
	if (!MobilityOffset || !cache::LocalCurrentWeapon) return;

	if (!config::config->data()->fast_move) {
		if (original_weapon_data.contains(cache::LocalCurrentWeapon) && original_weapon_data[cache::LocalCurrentWeapon].cached_mobility) {
			printf("resetting mobility to %f\n", original_weapon_data[cache::LocalCurrentWeapon].Mobility);
			driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + MobilityOffset, original_weapon_data[cache::LocalCurrentWeapon].Mobility);
			original_weapon_data[cache::LocalCurrentWeapon].cached_mobility = false;
		}

		return;
	}

	if (!original_weapon_data.contains(cache::LocalCurrentWeapon))
	{
		weapon_t data = { 0 };
		original_weapon_data[cache::LocalCurrentWeapon] = data;
		original_weapon_data[cache::LocalCurrentWeapon].Mobility = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + MobilityOffset);
		original_weapon_data[cache::LocalCurrentWeapon].cached_mobility = true;
	}
	else if (original_weapon_data.contains(cache::LocalCurrentWeapon) && !original_weapon_data[cache::LocalCurrentWeapon].cached_mobility)
	{
		original_weapon_data[cache::LocalCurrentWeapon].Mobility = driver::unsafe_read<float>((uintptr_t)cache::LocalCurrentWeapon + MobilityOffset);
		original_weapon_data[cache::LocalCurrentWeapon].cached_mobility = true;
	}

	driver::write<float>((uintptr_t)cache::LocalCurrentWeapon + MobilityOffset, original_weapon_data[cache::LocalCurrentWeapon].Mobility * 2.f);
}

void exploits::instant_reload(void)
{
	ONCE_GET_OFFSET("/Script/POLYGON.Item_Gun_General", "ReloadCharacterAnimation", ReloadCharacterAnimationOffset);
	ONCE_GET_OFFSET("/Script/POLYGON.Item_Gun_General", "ReloadFullCharacterAnimation", ReloadFullCharacterAnimationOffset);
	ONCE_GET_OFFSET("/Script/POLYGON.Item_Gun_General", "ReloadGunAnimation", ReloadGunAnimationOffset);
	ONCE_GET_OFFSET("/Script/POLYGON.Item_Gun_General", "ReloadFullGunAnimation", ReloadFullGunAnimationOffset);

	if (!ReloadCharacterAnimationOffset || !ReloadFullCharacterAnimationOffset || !ReloadGunAnimationOffset || !ReloadFullGunAnimationOffset) return;

	if (!config::config->data()->instant_reload) {
		if (original_weapon_data.contains(cache::LocalCurrentWeapon) && original_weapon_data[cache::LocalCurrentWeapon].cached_reload_anims) {
			driver::write<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadCharacterAnimationOffset, original_weapon_data[cache::LocalCurrentWeapon].ReloadCharacterAnimation);
			driver::write<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadFullCharacterAnimationOffset, original_weapon_data[cache::LocalCurrentWeapon].ReloadFullCharacterAnimation);
			driver::write<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadGunAnimationOffset, original_weapon_data[cache::LocalCurrentWeapon].ReloadGunAnimation);
			driver::write<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadFullGunAnimationOffset, original_weapon_data[cache::LocalCurrentWeapon].ReloadFullGunAnimation);
			original_weapon_data[cache::LocalCurrentWeapon].cached_reload_anims = false;
		}

		return;
	}

	if (!original_weapon_data.contains(cache::LocalCurrentWeapon))
	{
		weapon_t data = { 0 };

		data.ReloadCharacterAnimation = driver::unsafe_read<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadCharacterAnimationOffset);
		data.ReloadFullCharacterAnimation = driver::unsafe_read<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadFullCharacterAnimationOffset);
		data.ReloadGunAnimation = driver::unsafe_read<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadGunAnimationOffset);
		data.ReloadFullGunAnimation = driver::unsafe_read<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadFullGunAnimationOffset);
		data.cached_reload_anims = true;

		original_weapon_data[cache::LocalCurrentWeapon] = data;
	}
	else if (original_weapon_data.contains(cache::LocalCurrentWeapon) && !original_weapon_data[cache::LocalCurrentWeapon].cached_reload_anims)
	{
		original_weapon_data[cache::LocalCurrentWeapon].ReloadCharacterAnimation = driver::unsafe_read<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadCharacterAnimationOffset);
		original_weapon_data[cache::LocalCurrentWeapon].ReloadFullCharacterAnimation = driver::unsafe_read<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadFullCharacterAnimationOffset);
		original_weapon_data[cache::LocalCurrentWeapon].ReloadGunAnimation = driver::unsafe_read<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadGunAnimationOffset);
		original_weapon_data[cache::LocalCurrentWeapon].ReloadFullGunAnimation = driver::unsafe_read<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadFullGunAnimationOffset);
		original_weapon_data[cache::LocalCurrentWeapon].cached_reload_anims = true;
	}

	driver::write<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadCharacterAnimationOffset, nullptr);
	driver::write<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadFullCharacterAnimationOffset, nullptr);
	driver::write<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadGunAnimationOffset, nullptr);
	driver::write<void*>((uintptr_t)cache::LocalCurrentWeapon + ReloadFullGunAnimationOffset, nullptr);
}

float exploits::get_original_time_between_shots(void)
{
	if (!original_weapon_data.contains(cache::LocalCurrentWeapon)) {
		return 0.f;
	}

	if (original_weapon_data[cache::LocalCurrentWeapon].cached_firerate)
		return  original_weapon_data[cache::LocalCurrentWeapon].TimeBetweenShots;

	return 0;
}
